SUBROUTINE CBSPLGEN(PXIN,PYIN,PYINNEW,PYINPP,KNIN,PXOUT,PYOUT, &
  &  PYOUTP,PYOUTPP,PYOUTINT,KNOUT,KOPT,PSIG,NBCLFT &
  &  ,NBCRGT,XBCLFT,XBCRGT,YBCLFT,YBCRGT,KEXTRPOL,PXEXP0,PXEXPDL,KFLAG)
  !     =================================================================
  !
  !     NOTE: THIS ROUTINE INCLUDES THE STANDARD CUBIC SPLINE IF PTAUS=0 (i.e. psig=0):
  !           THEN PYINNEW IS NOT USED AND MDAMAT=3 IS SUFFICIENT
  !           (=> PYINNEW(1) OR PYINNEW=PYIN IS OK)
  !
  !     Interpolate (pxin,pyin) on (pxout,pyout) using
  !     Hirshman fitted cubic spline with ptaus value or
  !     standard cubic spline if PTAUS=0 (psig=ptaus*sigma/sigmamin)
  !
  !     KOPT = 0: ONLY INTERPOLATE FUNCTION INTO PYOUT
  !     KOPT = 1: INTERPOLATE FUNCTION INTO PYOUT AND 1ST DER. INTO PYOUTP
  !     KOPT = 2: AS KOPT=1 PLUS 2ND DER. INTO PYOUTPP
  !     KOPT = 3: AS KOPT=2 PLUS INTEGRAL FROM PXIN(1) UP TO PXOUT(J)
  !
  !     SEE COMMENTS FOR ROUTINE CBFITBND FOR MORE INFORMATION
  !
  !     IF LAPACK ROUTINES NOT AVAILABLE, USE spgbtrf_s.f
  !     (LAPACK SOURCE COPIED FROM NETLIB.ORG)
  !
  !     PXIN    : INPUT ABSCISSA (GIVEN DATA)
  !     PYIN    : INPUT VALUES OF FUNCTION AT PXIN(I),I=1,KNIN
  !     PYINNEW : IF PTAUS.NE.0, THEN PYNEW CONTAINS ON OUTPUT THE NEW VALUES
  !     .         OF THE FUNCTION AT PXIN(I) FOR THE CUBIC SPLINE FIT
  !     PYINPP  : SECOND DER. OF THE CUBIC SPLINE FIT FOR (PXIN,PYIN) IF PTAUS=0 OR
  !     .         ON (PXIN,PYNEW) OTHERWISE
  !     KNIN    : NUMBER OF INPUT POINTS
  !     PXOUT   : X VALUES AT WHICH THE FUNCTION HAS TO BE INTERPOLATED (INPUT)
  !     PYOUT   : INTERPOLATED VALUES AT PXOUT(I),I=1,KNOUT (OUTPUT)
  !     PYOUTP  : INTERPOLATED VALUES OF 1ST DER. OF FUNCTIONS AT PXOUT(I) (OUTPUT, IF KOPT.GE.1)
  !     PYOUTPP : INTERPOLATED VALUES OF 2ND DER. OF FUNCTIONS AT PXOUT(I) (OUTPUT, IF KOPT.EQ.2)
  !     PYOUTINT: INTEGRAL OF Y FROM PXIN(1) TO PXOUT(J)
  !     KNOUT   : NUMBER OF POINTS FOR OUTPUT
  !     KOPT    : SEE ABOVE
  !     PSIG    : SIGMA at each point, normalized by minimum sigma, times PTAUS
  !     PTAUS   : WEIGHT OF SECOND DERIVATIVE IN THE CHI**2 TO BE MINIMIZED. PTAUS=0 GIVES THE
  !     .         STANDARD CUBIC SPLINE. LARGER VALUES OF PTAUS WILL SMOOTH MORE THE 2ND DER.
  !     NBCLFT  : FOR LEFT B.C., VALUE SHOULD BE 0,1,2,10,11 OR 12. (SEE ROUTINE CBFITBND BELOW)
  !     NBCRGT  : FOR RIGHT B.C. (SEE ROUTINE CBFITBND BELOW)
  !     XBCLFT  : FOR LEFT B.C., USED ONLY IF NBCLFT.GE.10 (SEE ROUTINE CBFITBND BELOW)
  !     XBCRGT  : FOR RIGHT B.C., USED ONLY IF NBCRGT.GE.10 (SEE ROUTINE CBFITBND BELOW)
  !     YBCLFT  : VALUE OF LEFT B.C.
  !     YBCRGT  : VALUE OF RIGHT B.C.
  !     .         STANDARD B.C. (SECOND DER. = 0) IS OBTAINED WITH:
  !     .         NBCLFT = NBCRGT = 0 AND YBCLFT = YBCRGT = 0.
  !     KEXTRPOL: OPTION ON HOW TO EXTRAPOLATE THE FUNCTION IF PXOUT(I) IS OUTSIDE [PXIN(1),PXIN(KNIN)]
  !     .       = 0: STOP WITH ERROR MESSAGE IF OUT OF BOUND
  !     .       = 1: LINEAR EXTRAPOLATION
  !     .       = 2: USE QUADRATIC INTERPOLATION IF X OUT OF BOUND
  !     .       = 3: USE CUBIC INTERPOLATION IF X OUT OF BOUND
  !     .       = 21: USE QUADRATIC WITHIN ALFA*DELTA_X AND LINEAR FURTHER
  !     .       = 31: USE CUBIC WITHIN ALFA*DELTA_X AND LINEAR    FURTHER
  !     .       = 32: USE CUBIC WITHIN ALFA*DELTA_X AND QUADRATIC FURTHER
  !     PXEXP0  : PTAUS IS WEIGHTED BY AN EXP(-((X-PXEXP0)/PXEXPDL)**2)
  !     PXEXPDL : IF PXEXP0 NOT IN [PXIN(1),PXIN(KNIN)], EXP() IGNORED AND PTAUS=CST
  !     .         (SEE ROUTINE CBFITBND BELOW)
  !     .         GIVE PXEXP0=PXIN(1)-1. AND PXEXPDL=1. TO GET CONSTANT PTAUS
  !     KFLAG   : ERROR FLAG: IF NOT 0, THERE IS A PROBLEM
  !
  !-----------------------------------------------------------------------
  USE prec_rkind
  implicit none
  REAL(RKIND) :: EPSILON
  PARAMETER(EPSILON = 1.0E-10_RKIND)
  ! arguments
  integer :: knin, knout, kopt, nbclft, nbcrgt, kextrpol
  integer:: kflag
  real(rkind) :: PXIN(KNIN), PYIN(KNIN), PXOUT(KNOUT), PSIG(KNIN), &
    & xbclft, xbcrgt, ybclft, ybcrgt, pxexp0, pxexpdl
  real(rkind):: PYINNEW(KNIN), PYINPP(KNIN), PYOUT(KNOUT), PYOUTP(KNOUT), &
    & PYOUTPP(KNOUT), PYOUTINT(KNOUT)
  !
  integer :: mdmatot, i, ioptmono
  REAL(RKIND) :: zy, zyp, zypp
  !
  !-----------------------------------------------------------------------
  !     0. CHECK INPUT CONSISTENCY
  !
  KFLAG = 0
  IF (PSIG(1) .EQ. 0._RKIND) THEN
    IF (NBCLFT.GE.10 .OR. NBCRGT.GE.10 .OR. NBCLFT.EQ.2 &
      &  .OR. NBCRGT.EQ.2) THEN
      PRINT *,' PTAUS=0, BUT NEED SMOOTHING, WHEN'
      PRINT *,'     NBCLFT.GE.10 .OR. NBCRGT.GE.10 .OR.', &
        &      ' NBCLFT.EQ.2 .OR. NBCRGT.EQ.2'
      PRINT *,' NBCLFT = ',NBCLFT
      PRINT *,' NBCRGT = ',NBCRGT
      !%OS          STOP 'TAU=0'
      KFLAG = 1
      return
    ENDIF
  ENDIF
  !
  !   PXIN in ASCENDING ORDER
  !
  DO i=1,KNIN-1
    if (PXIN(i) .GE. PXIN(i+1)) then
      print *,' xin not in ascending order:'
      print *,' xin(',i,')= ',PXIN(i),'   >=   xin(',i+1,')= ', &
        &      PXIN(i+1)
      KFLAG = 2
      RETURN
    endif
  END DO
  !
  CALL CBFITBND(PXIN,PYIN,PYINNEW,KNIN,PYINPP,PSIG,NBCLFT,NBCRGT, &
    &  XBCLFT,XBCRGT,YBCLFT,YBCRGT,PXEXP0,PXEXPDL)
  !
  !L    2. COMPUTE INTERPOLATED VALUE AT EACH PXOUT
  !
  IF (PSIG(1) .EQ. 0.0_RKIND) THEN
    CALL SPLIBNDA(PXIN,PYIN   ,PYINPP,KNIN,PXOUT,PYOUT,PYOUTP,PYOUTPP,PYOUTINT,KNOUT, &
      &      KEXTRPOL,KOPT)
  ELSE
    CALL SPLIBNDA(PXIN,PYINNEW,PYINPP,KNIN,PXOUT,PYOUT,PYOUTP,PYOUTPP,PYOUTINT,KNOUT, &
      &      KEXTRPOL,KOPT)
  ENDIF
  !
  RETURN
END SUBROUTINE CBSPLGEN
